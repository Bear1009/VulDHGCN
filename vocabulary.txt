import pickle
from dataclasses import dataclass
from os.path import exists
from typing import Dict, List
from src.utils import PAD, UNK, MASK
from gensim.models import KeyedVectors

TOKEN_TO_ID = "token_to_id"


@dataclass
class Vocabulary:
    token_to_id: Dict[str, int]

    """
    build vocabulary from word2vec wv

    Args:
        w2v_path: path to word2vec wv
        speicial_tokens:


    Returns:

    """
    # 这段代码定义了一个名为build_from_w2v的函数，用于从Word2Vec模型构建词汇表（Vocabulary）对象。
    @staticmethod
    def build_from_w2v(w2v_path: str, speicial_tokens: List[str] = [PAD, UNK, MASK]):

        # 使用了Python的断言（assert）语句来检查w2v_path变量所代表的路径是否存在。如果路径不存在，断言会触发一个AssertionError异常，并显示指定的错误消息。
        assert exists(w2v_path), f"{w2v_path} not exists!"

        # 指定是否使用内存映射（memory-mapped）模式加载模型文件。如果设置为 "r"，则表示以只读模式加载模型文件，并使用内存映射模式进行操作，以减少内存占用。默认为 None，表示不使用内存映射模式。
        model = KeyedVectors.load(w2v_path, mmap="r")  #
        # 创建一个空的字典，用于存储词语和对应的索引
        attr = dict()
        # 使用enumerate函数遍历special_tokens列表，将每个特殊令牌与其在列表中的索引关联起来，并将其添加到attr字典中。
        for idx, tk in enumerate(speicial_tokens):
            attr[tk] = idx
        # 遍历Word2Vec模型的词汇表中的每个单词wd，并将其索引加上特殊令牌的数量，然后将其添加到attr字典中。
        for wd in model.vocab:
            attr[wd] = model.vocab[wd].index + len(speicial_tokens)
        return Vocabulary(token_to_id=attr)

    # 这段代码定义了一个静态方法load_vocabulary，用于从文件加载词汇表（Vocabulary）对象。
    # 这个方法用于从文件中恢复保存的词汇表，以便在需要时加载已经构建好的词汇表对象。
    @staticmethod
    def load_vocabulary(vocabulary_path: str) -> "Vocabulary":
        if not exists(vocabulary_path):
            raise ValueError(f"Can't find vocabulary in: {vocabulary_path}")
        with open(vocabulary_path, "rb") as vocabulary_file:
            # 通过使用pickle.load(vocabulary_file)从文件中加载词汇表字典对象。
            vocabulary_dicts = pickle.load(vocabulary_file)
        # 从加载的词汇表字典对象中提取token_to_id，即词语到标识符（ID）的映射字典。
        token_to_id = vocabulary_dicts[TOKEN_TO_ID]
        # 最后，使用Vocabulary(token_to_id=token_to_id)创建一个词汇表对象，并将其返回。
        return Vocabulary(token_to_id=token_to_id)

    # 用于将词汇表（Vocabulary）对象保存到文件。
    # 这个方法用于将词汇表对象保存到文件，以便在需要时可以从文件中加载词汇表。
    def dump_vocabulary(self, vocabulary_path: str):
        # 首先，使用open(vocabulary_path, "wb")打开词汇表文件，并以二进制写入模式打开文件。
        with open(vocabulary_path, "wb") as vocabulary_file:
            # 然后，创建一个词汇表字典vocabulary_dicts，其中包含词汇表对象的token_to_id属性。
            vocabulary_dicts = {
                TOKEN_TO_ID: self.token_to_id,
            }
            # 最后，使用pickle.dump(vocabulary_dicts, vocabulary_file)将词汇表字典对象写入文件中。
            pickle.dump(vocabulary_dicts, vocabulary_file)

'''
    这些方法提供了在词汇表对象中进行词汇转换和获取相关信息的功能，
    例如将词汇转换为标识符、将词汇列表转换为标识符列表，以及获取词汇表的大小和填充词汇的标识符。
'''

    # 该方法接受一个词汇（token）作为输入，并返回其对应的标识符（ID）。如果词汇不存在于词汇表中，则返回未知词汇（UNK）的标识符。
    def convert_token_to_id(self, token: str):
        return self.token_to_id.get(token, self.token_to_id[UNK])

    # 该方法接受一个词汇列表（tokens）作为输入，并返回对应的标识符列表。
    # 对于列表中的每个词汇，调用convert_token_to_id方法将其转换为标识符，并将结果存储在列表中返回。
    def convert_tokens_to_ids(self, tokens: List[str]):
        return [self.convert_token_to_id(token) for token in tokens]

    # 该方法返回词汇表的大小，即词汇表中唯一词汇的数量。
    def get_vocab_size(self):
        return len(self.token_to_id)

    # 该方法返回填充词汇（PAD）的标识符。
    def get_pad_id(self):
        return self.convert_token_to_id(PAD)
